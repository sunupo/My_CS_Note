	面试官您好，我叫孙敬钦，本科就读于黑龙江东北石油大学（物联网工程专业），所学的内容包括硬件相关的数字逻辑，数字电路，单片机等，和计算机网络，数据库，操作系统等。大二上学期参加过大学生数学建模。大二暑假，参加了老师实验室的东西，主要是跑现场，没有学到太多东西（到现场去设备拍照，一些业务上的需求交洽，的对设备采集的数据进行处理等），大三参加过一次蓝桥杯单片机设计大赛，获得过国家励志奖学金。**大学期间参加过学生会，铁人志愿者等社团，多次参加校运动会。**大学四年专业综合成绩第一，推免到重庆大学（计算机技术专业）。研究生开学期间，参与师兄做的一个android的社交app，接触不太多，主要是自学了android和java的知识。研一主要是课程学习，成绩约前20%，研一下学期到研二上学期，在研究生mis系统做助管，一些bug修复和数据库信息的简单维护；研一下学期，做过一个关于宠护互助App的项目，负责android客户端和程序后端的开发，app主要是关于帮助宠物领养送养的（是一个老师私人的项目）。研二上学期申请了一门课程的助教，研究方向主要是推荐系统。**研二下学期疫情期间在家写了一篇推荐系统中关于“好友推荐”的论文在投。5月份到6月份，参加了一个腾讯算法广告大赛，目标是预测用户的属性：年龄和性别。后面这段时间就开始准备找工作了。

## △自我介绍	

​	    面试官您好，我叫孙敬钦，本科就读于黑龙江东北石油大学（物联网工程专业），所学的内容包括硬件相关的数字逻辑，数字电路，单片机等，和计算机网络，数据库，操作系统等。大二上学期参加过大学生数学建模，最终获得了省二等奖。大二暑假，参加了老师实验室的东西，主要是跑现场，没有学到太多东西（到现场去设备拍照，一些业务上的需求交洽，的对设备采集的数据进行处理等），大三参加过一次蓝桥杯单片机设计大赛，获得了省三等奖，获得过国家励志奖学金。**大学期间参加过学生会，铁人志愿者等社团，多次参加校运动会。**大学四年专业综合成绩第一，推免到重庆大学（计算机技术专业）。研究生开学期间，参与学习了师兄做的一个spring和mybatis搭建的后端和android客户端的一个项目，社交app，接触不太多，主要是自学了android和java的知识。研一主要是课程学习，成绩约前20%，研一下学期到研二上学期，在研究生mis系统做助管，一些bug修复和数据库信息的简单维护；研一下学期，做过一个关于宠护互助App的项目，负责android客户端和程序后端的开发，app主要是关于帮助宠物领养送养的（是一个老师私人的项目）。研二上学期申请了一门课程的助教，研究方向主要是推荐系统，**参加了一个高校间的体育比赛“高校百英里”接力赛，在成都分站获得了团体冠军，上海决赛获得了团体第三。**研二下学期疫情期间在家写了一篇推荐系统中关于“好友推荐”的论文在投，指导一个同学做了一个关于滑动验证码模拟登陆的模块，识别验证码中的滑块位置，用来模拟真实用户登录的过程。5月份到6月份，参加了一个腾讯算法广告大赛，目标是预测用户的属性：年龄和性别，最终遗憾没能进入复赛。后面这段时间就开始准备找工作了.

   面试官您好，我叫孙敬钦，本科就读于黑龙江东北石油大学（物联网工程专业）。大二上学期参加过大学生数学建模，最终获得了省二等奖。大三参加过一次蓝桥杯单片机设计大赛，获得了省三等奖，获得过国家励志奖学金。大学四年专业综合成绩第一，推免到重庆大学（计算机技术专业），本科的毕业论文主要是通过单片机设计了一个模拟的火灾监控预警系统。研究生开学期间，参与学习了师兄做的一个spring和mybatis搭建的后端和android客户端的一个项目，社交app，我在其中主要是自学了android和java的知识。研一下学期到研二上学期，在研究生mis系统做助管，一些bug修复和数据库信息的简单维护（数据库语句，前端界面这些）；研一下学期，做过一个关于宠护互助App的项目，负责android客户端和程序后端的开发，app主要是关于帮助宠物领养送养的（是一个老师私人的项目，是一个参赛作品）。研究方向主要是推荐系统。发表了一篇关于“好友推荐”和一篇关于“点击率预测”的论文。大论文是“基于因子分解机和深度学习的推荐系统算法研究”。

指导一个同学做了一个关于滑动验证码模拟登陆的模块，识别验证码中的滑块位置，用来模拟真实用户登录的过程。

5月份到6月份，参加了一个腾讯算法广告大赛，目标是预测用户的属性：年龄和性别，最终遗憾没能进入复赛。后面这段时间就开始准备找工作了.

华为的技术能力较强，可以学习到先进的技术，更好地成长。华为的发展策略与国家发展相连

最近一段时间正在撰写我的论文：

AutoHFIS：Automatic High-order Feature Interaction Selection  for Click-Through Rate Prediction in Recommendation System

AutoHFIS：用于推荐系统中点击率预估的自动高阶交互特征选择

## *学了哪些知识*。

​	java python，推荐系统，web开发、客户端开发等

## 数据结构看了那些书

​	严蔚敏的数据结构

## 数组链表区别

链表是链式的存储结构；数组是顺序的存储结构。
一、主体不同bai
1、数组：是有序的元素序列。将有限个类型相同的变量的集合命名。
2、链表：是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
二、组成不同
1、数组：是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。
2、链表：由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。
三、特点不同
1、数组：所有元素都具有相同类型。数组中的元素存储在一个连续性的内存块中，并通过索引来访问。但插入与删除比较复杂。
2、链表：可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。

## TCP、UDP使用场景

socket，datagramsocket
TCP应用场景：
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
UDP应用场景：
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。
区别

面向连接VS无连接
TCP建立一个连接需要3次握手IP数据包，断开连接需要4次握手。另外断开连接时发起方可能进入TIME_WAIT状态长达数分钟（视系统设置，windows一般为120秒），在此状态下连接（端口）无法被释放。
UDP不需要建立连接，可以直接发起。
可靠VS不可靠
TCP利用握手、ACK和重传机制，udp没有。
1，校验和（校验数据是否损坏）；
2，定时器（分组丢失则重传）；
3，序列号（用于检测丢失的分组和重复的分组）；
4，确认应答ACK（接收方告知发送方正确接收分组以及期望的下一个分组）；
5，否定确认（接收方通知发送方未被正确接收的分组）；
6，窗口和流水线（用于增加信道的吞吐量）。（窗口大小：无需等待确认应答而可以继续发送数据的最大值）
有序性
TCP利用seq序列号对包进行排序，udp没有。
面向字节流vs面向报文
面向报文
面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。（一个upd的最大报文长度2^16-1-20-8,20是ip报文头，8是udp报文头）
面向字节流
面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。
tcp有流量控制，udp没有
tcp的头部比20bytes，udp8byres

## 为什么tcp是可靠传输

## 同步套接字和异步套接字区别

> [1]: https://blog.csdn.net/fuyuehua22/article/details/38304495	"阻塞与非阻塞、同步与异步套接字之间的区别"

### **blocking IO** 

在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：

![](../pic/0_1280550787I2K8.gif)

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。
所以，blocking IO的特点就是在IO执行的两个阶段都被block了。

### **non-blocking IO**

linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：

![](../pic/0_128055089469yL.gif)

从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。
所以，用户进程其实是需要不断的主动询问kernel数据好了没有\\。

### **IO multiplexing**

IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：

![](..\pic\0_1280551028YEeQ.gif)

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）**在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。**

###  **Asynchronous I/O**

linux下的asynchronous IO其实用得很少。先看一下它的流程：

![](..\pic\0_1280551287S777.gif)

用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：

### blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。

先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。

在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：
    **A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;    An asynchronous I/O operation does not cause the requesting process to be blocked;** 
两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。

各个IO Model的比较如图所示：

![](..\pic\0_1280551552NVgW.gif)

  经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。

最后，再举几个不是很恰当的例子来说明这四个IO Model:
有A，B，C，D四个人在钓鱼：
A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；
B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；
C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；
D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。  

[](https://blog.csdn.net/fuyuehua22/article/details/38304495)

[]: https://blog.csdn.net/weililansehudiefei/article/details/70885515	"IO多路复用"

在同步模式中，对执行网络操作的函数（如Send和receive）的调用一直等到操作完成后才将控制权返回给调用程序；在异步模式中，这些调用立即返回控制权

在代码中也可以一眼看出是异步套接字还是同步套接字，同步模式中使用Accept方法，对应的异步模式中使用BeqinAccept和EndAccept方法。

## 面向对象三大特性，如何在项目中体现着些特性。

- 1.封装：根据职责将属性和方法封装到一个抽象的类中

- 2.继承：实现代码的重用，相同的代码不需要重复的写
  单继承：
  子类拥有父类的所有方法和属性(子类只需封装自己特有的方法)
- 3.多态：多态就是不同的对象可以调用相同的方法然后得到不同的结果，
  有点类似接口类的感觉，在python中处处体现着多态，比如不管你是列表
  还是字符串还是数字都可以使用+和*。

## 指针、引用区别

1. (1)指针是实体，引用是别名，没有空间。
2. (2)引用定义时必须初始化，指针不用。
3. (3)指针可以改，引用不可以。
4. (4)引用不能为空，指针可以。
5. (5)Sizeof(引用)计算的是它引用的对象的大小，而sizeof(指针)计算的是指针本身的大小。
6. (6)不能有NULL引用，引用必须与一块合法的存储单元关联。
7. (7)给引用赋值修改的是该引用与对象所关联的值，而不是与引用关联的对象。
8. (8)如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏。
9. (9)对引用的操作即是对变量本身的操作。

## 项目用到了什么（数据库、队列、设计模式）就用问什么

## 多进程与多线程的区别

  多进程和多线程的主要区别是：线程是进程的子集（部分），一个进程可能由多个线程组成。多进程的数据是分开的、共享复杂，需要用IPC；但同步简单。多线程共享进程数据，共享简单；但同步复杂。

  什么是多进程？

进程是程序在计算机上的一次执行活动，即正在运行中的应用程序，通常称为进程。当你运行一个程序，你就启动了一个进程。每个进程都有自己独立的地址空间(内存空间)，每当用户启动一个进程时，操作系统就会为该进程分配一个独立的内存空间，让应用程序在这个独立的内存空间中运行。

在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程，也称多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。

多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。

什么是多线程？

线程是一个轻量级的子进程，是最小的处理单元；是一个单独的执行路径。可以说：线程是进程的子集（部分），一个进程可能由多个线程组成。

线程是独立的。如果在一个线程中发生异常，则不会影响其他线程。它使用共享内存区域。

多线程是一种执行模型，它允许多个线程存在于进程的上下文中，以便它们独立执行但共享其进程资源。

多进程和多线程的区别

![1597730554776](..\pic\1597730554776.png)



## 互斥量和信号量区别、应用场景

具体应用：信号量可以用于控制进程数，互斥锁可以用于并发加锁

# 互斥量和信号量的区别

 来源 https://www.cnblogs.com/lbsx/archive/2009/08/03/1537698.html

\1. **互斥量用于线程的互斥，信号量用于线程的同步。**

这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。

互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源

以上区别是主要想记住的。

note:**信号量可以用来实现互斥量的功能**

\2. 互斥量值只能为0/1，信号量值可以为非负整数。

也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。

\3. **互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。**

## springboot spring

## 设计模式

https://www.runoob.com/design-pattern/prototype-pattern.html

java 立项，spring boot  分布式 微服务 大数据

vue， react。



```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
public class Main{
	public static void main(String[] args) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] strings;
		int n,x;
		try {
			strings = br.readLine().split(" ");
			n=Integer.parseInt(strings[0]);
			x = Integer.parseInt(strings[1]);
			if (n==0 || x==0){
				System.out.print(0);
			}
			float[][] nums = new float[n][2];
			for (int i = 0; i < n; i++) {
				String[] strings2=br.readLine().split(" ");
				nums[i][0]=Float.valueOf(strings2[0]);
				nums[i][1]=Float.valueOf(strings2[1]);
			}
		
			float[][] dp = new float[n][x+1];
			for (int i = 0; i <=x; i++) {
				if(i>nums[0][0])
					dp[0][i]=nums[0][1];
			}
			for (int i =1; i < n; i++) {
				for (int j = 0; j <= x; j++) {
					if (nums[i][0]>j)
						dp[i][j]=dp[i-1][j];
					else
						dp[i][j]=Math.max(dp[i-1][j], dp[i-1][j-(int)nums[i][0]]+nums[i][1]);
				}
			}
			System.out.print((int)dp[n-1][x]);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
}
```

~~~python
import copy


def bfs(last_data, idx):
    data = copy.deepcopy(last_data)
    if idx != 3:
        data[idx] += 1

    if min(data) == max(data):
        res.append(data)

        return True
    data = sorted(data)
    if data[3] >= 2:
        data[3] -= 2
        return bfs(data, 0) or bfs(data, 1) or bfs(data, 2)

    else:
        return False

if __name__ == "__main__":
    # data = list(map(int, input().split()))
    data=[1,2,2,4]
    data=[7,3,6,4]
    res=[]
    if bfs(sorted(data), 3):
        print("main",res)
~~~

~~~
	
~~~

## 零钱兑换

```java
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # coins=coins[::-1]
        dp=[[0]*(amount+1) for _ in range(len(coins)+1)]
        dp[0][0]=1
        # dp[i][j]=dp[i-1][j] +dp[i-1][j-coins[i-1]]
        for i in range(1,len(coins)+1):
            for j in range(amount+1):
                # for k in range(int(j/coins[i-1]+1)):
                #     dp[i][j]+=dp[i-1][j-k*coins[i-1]]
                dp[i][j]=dp[i-1][j]+(dp[i][j-coins[i-1]] if j>=coins[i-1] else 0)
        print(dp)
        return dp[len(coins)][amount]
```

## 二叉树包含链表

~~~python
class Solution:
    def dfs(self, head: ListNode, rt: TreeNode) -> bool:
        if not head:
            return True
        if not rt:
            return False
        if rt.val != head.val:
            return False
        return self.dfs(head.next, rt.left) or self.dfs(head.next, rt.right)

    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        if not root:
            return False
        return self.dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)
~~~

## 0-1背包

~~~c++
int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
    // vector 全填入 0，base case 已初始化
    vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0)); // 前i个物品，当前背包容量为j，这种情况下可以装的最大价值为dp[i][j],dp[i][j]含义指的是装了dp[i][j]这么多价值，剩余的空间为j
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i-1] < 0) {
                // 当前背包容量装不下，只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], 
                               dp[i - 1][w]);
            }
        }
    }

    return dp[N][W];
}
~~~

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
public class Main{
	public static void main(String[] args) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] strings;
		int n,x; //n数量，x容量
		try {
			strings = br.readLine().split(" ");
			n=Integer.parseInt(strings[0]);
			x = Integer.parseInt(strings[1]);
			if (n==0 || x==0){
				System.out.print(0);
			}
			float[][] nums = new float[n][2];
			for (int i = 0; i < n; i++) {
				String[] strings2=br.readLine().split(" ");
				nums[i][0]=Float.valueOf(strings2[0]); //重量
				nums[i][1]=Float.valueOf(strings2[1]); //价值
			}
		
			float[][] dp = new float[n][x+1];// 前i个物品，当前背包容量为j，这种情况下可以装的最大价值为dp[i][j]
			for (int i = 0; i <=x; i++) {
				if(i>nums[0][0])
					dp[0][i]=nums[0][1];
			}
			for (int i =1; i < n; i++) {
				BigInteger a;
				for (int j = 0; j <= x; j++) {
					if (nums[i][0]>j)
						dp[i][j]=dp[i-1][j];
					else
						dp[i][j]=Math.max(dp[i-1][j], dp[i-1][j-(int)nums[i][0]]+nums[i][1]);
				}
			}
			System.out.print((int)dp[n-1][x]);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
}
~~~

m