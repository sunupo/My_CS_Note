# 1.session维持一个会话

 **随机数+时间+jvmid**；

# 如何根据sessionID获取session解决方案

### 一、写在前面

最近在做一个项目的时候，本来是想通过session来存一些数据的，但是，发现当两次访问的方法不同时，后台的session是不一样的，也就是说`sessionId`，不一致，所以导致的问题就是：当我需要从session取值的时候，总是出现取不到值的情况，后面也想过用redis，但是也被坑了。

后来，想到就是通过和前端沟通，通过`sessionId`和前端进行交互，来保证每一次的session是一致的，所以就想到了下面的方法。

### 二、以前解决方法

根据sessionID有一个比较简单的方法，使用session上下文即可

```
HttpSession sess = session.getSessionContext().getSession(sid)  
1
```

不过很可惜，java之后处于安全性考虑，不建议使用这个方法，虽然我不知道为什么对安全性会有影响，但是既然java不建议用了。下面来分享一个方法，使用session监听器配合一个静态的hashmap即可实现。

### 三、新的解决方法

首先，创建自己的sessionContext

```
 public class MySessionContext {  
        private static MySessionContext instance;  
        private HashMap<String,HttpSession> sessionMap;  
      
        private MySessionContext() {  
            sessionMap = new HashMap<String,HttpSession>();  
        }  
      
        public static MySessionContext getInstance() {  
            if (instance == null) {  
                instance = new MySessionContext();  
            }  
            return instance;  
        }   
      
        public synchronized void addSession(HttpSession session) {  
            if (session != null) {  
                sessionMap.put(session.getId(), session);  
            }  
        }  
      
        public synchronized void delSession(HttpSession session) {  
            if (session != null) {  
                sessionMap.remove(session.getId());  
            }  
        }  
      
        public synchronized HttpSession getSession(String sessionID) {  
            if (sessionID == null) {  
                return null;  
            }  
            return sessionMap.get(sessionID);  
        }  
      
    }  
1234567891011121314151617181920212223242526272829303132333435
```

然后建立session监听，要实现HttpSessionListener接口

```
  public class SessionListener implements HttpSessionListener {  
          
        private MySessionContext myc = MySessionContext.getInstance();  
          
        public void sessionCreated(HttpSessionEvent httpSessionEvent) {  
            HttpSession session = httpSessionEvent.getSession();  
            myc.addSession(session);  
        }  
      
        public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {  
            HttpSession session = httpSessionEvent.getSession();  
            myc.delSession(session);  
        }  
      
    }  
123456789101112131415
```

接着，在web.xml中配置session监听器

```
   <listener>  
        <listener-class>com.chinapost.manager.utils.SessionListener</listener-class>  
    </listener>  
123
```

**注意：这个SessionListener是监听器的路径**

完事，大功告成，之后在代码中直接获取就OK了

```
    MySessionContext myc= MySessionContext.getInstance();  
    HttpSession sess = myc.getSession(sessionId);  
```

好了，这样就完美的解决了问题了

# 2.宠物互助app

这个平台主要功能是帮助宠物送养领养信息完成一个匹配的过程。想要送养宠物的用户，可以再平台上发布一条动态（包括属性选择：宠物类型、名称、年龄、体重等信息。和文字简介：介绍为什么想要送养宠物，宠物的习惯，宠物的来历，是流浪动物还是家养的宠物等信息。领养宠物的人也可已在平台发布一条领养信息，包括自己想要领养的宠物类型，大小，地点等等。用户可以再动态下面进行交流，或者通过一个即时通信的sdk进行交流，融云这个sdk能够完成及时的推送，论坛下面的互助信息也是创建了一个android口泰服务，监听服务器的消息，如果服务器针对每个用户有新的消息来了【发布评论的时候，需要连接到服务器，这个时候服务器根据你发不得这条信息，推送给这条信息的发布者】在通知栏上显示新信息的摘要）

推荐：

java web开发技术有很多，大概罗列如下：

前端主要用的是android，okhttp与后端发起网络连接。

后端跨哪家主要用的是spring+mybatis

数据库用的mysql

一些页面展示就用的jsp

## 1、后台框架部分，

常用spring、struts2等，用来帮助对项目的持久层、业务dao层、页面控制层的三层架构开发；当然，如果使用spring框架的话，还提供spring security、切面、依赖注入等现成的工具包，提高开发效率并且方便你集成一些第三方的扩展；

## 2、数据持久层方面，

用到的有mybatis、hibernate等持久技术，这些可以帮助快速建立数据库的访问和数据持久化工作，并且方便管理；

## 3、动态展示，

一般用jsp展示。但可以考虑模板引擎技术，如velocity、FreeMarker 等技术，可以帮助你规范化开发页面，提高执行效率；![img](C:\Users\孙敬钦\Desktop\孙敬钦的简历\CS-Notes-master\mynote\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbl9qdW5iaWFv,size_16,color_FFFFFF,t_70)

## 4、前端框架，

有很多，如bootstraps3、angularjs、easyui、jquery等



json

okhttp

gridle缓存

spring+mybatis

## 5.问题

### 1.图片加载缓慢：Glide缓存简介

Glide的缓存设计可以说是非常先进的，考虑的场景也很周全。在缓存这一功能上，Glide又将它分成了两个模块，一个是内存缓存，一个是硬盘缓存。

这两个缓存模块的作用各不相同，内存缓存的主要作用是防止应用重复将图片数据读取到内存当中，而硬盘缓存的主要作用是防止应用重复从网络或其他地方重复下载和读取数据。

内存缓存和硬盘缓存的相互结合才构成了Glide极佳的图片缓存效果，那么接下来我们就分别来分析一下这两种缓存的使用方法以及它们的实现原理。

### 2.bitmap

## 8.2.2 Bitmap引起的OOM问题

### *分类* [Android 基础入门教程](https://www.runoob.com/w3cnote_genre/android)

https://www.runoob.com/w3cnote/android-tutorial-bitmap2.html

为了防止oom，在图片加载的时候做了一些处理。采用低内存编码和图片压缩，结合glide缓存和softreference

## 本节引言：

> 上节，我们已经学习了Bitmap的基本用法，而本节我们要来探讨的Bitmap的OOM问题， 大家在实际开发中可能遇到过，或者没遇到过因为Bitmap引起的OOM问题，本节我们 就来围绕这个话题来进行学习~了解什么是OOM，为什么会引起OOM，改善因Bitmap引起的 OOM问题~

------

## 1.什么是OOM？为什么会引起OOM？

答：**Out Of Memory**(内存溢出)，我们都知道Android系统会为每个APP分配一个独立的工作空间， 或者说分配一个单独的Dalvik虚拟机，这样每个APP都可以独立运行而不相互影响！而Android对于每个 Dalvik虚拟机都会有一个最大内存限制，如果当前占用的内存加上我们申请的内存资源超过了这个限制 ，系统就会抛出OOM错误！另外，这里别和RAM混淆了，即时当前RAM中剩余的内存有1G多，但是OOM还是会发生！别把RAM(物理内存)和OOM扯到一起！另外RAM不足的话，就是杀应用了，而不是仅仅是OOM了！ 而这个Dalvik中的最大内存标准，不同的机型是不一样的，可以调用：

```
ActivityManager activityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
Log.e("HEHE","最大内存：" + activityManager.getMemoryClass());
```

获得正常的最大内存标准，又或者直接在命令行键入：

```
adb shell getprop | grep dalvik.vm.heapgrowthlimit
```

你也可以打开系统源码/system/build.prop文件，看下文件中这一部分的信息得出：

```
dalvik.vm.heapstartsize=8m
dalvik.vm.heapgrowthlimit=192m
dalvik.vm.heapsize=512m
dalvik.vm.heaptargetutilization=0.75
dalvik.vm.heapminfree=2m
dalvik.vm.heapmaxfree=8m
```

我们关注的地方有三个：heapstartsize堆内存的初始大小，heapgrowthlimit标准的应用的最大堆 内存大小，heapsize则是设置了使用android:largeHeap的应用的最大堆内存大小！

我这里试了下手头几个机型的正常最大内存分配标准：

![img](https://www.runoob.com/wp-content/uploads/2015/10/50717226.jpg)

你也可以试试自己手头的机子~

好啦，不扯了，关于OOM问题的产生，就扯到这里，再扯就到内存管理那一块了，可是个大块头， 现在还啃不动...下面我们来看下避免Bitmap OOM的一些技巧吧！

------

## 2.避免Bitmap引起的OOM技巧小结

------

### 1）采用低内存占用量的编码方式

上一节说了**BitmapFactory.Options**这个类，我们可以设置下其中的inPreferredConfig属性， 默认是**Bitmap.Config.ARGB_8888**，我们可以修改成**Bitmap.Config.ARGB_4444**
Bitmap.Config ARGB_4444：每个像素占四位，即A=4，R=4，G=4，B=4，那么一个像素点占4+4+4+4=16位
Bitmap.Config ARGB_8888：每个像素占八位，即A=8，R=8，G=8，B=8，那么一个像素点占8+8+8+8=32位
默认使用ARGB_8888，即一个像素占4个字节！

------

## 2）图片压缩

同样是BitmapFactory.Options，我们通过**inSampleSize**设置缩放倍数，比如写2，即长宽变为原来的1/2，图片就是原来的1/4，如果不进行缩放的话设置为1即可！但是不能一味的压缩，毕竟这个值太小 的话，图片会很模糊，而且要避免图片的拉伸变形，所以需要我们在程序中动态的计算，这个 inSampleSize的合适值，而Options中又有这样一个方法：**inJustDecodeBounds**，将该参数设置为 true后，decodeFiel并不会分配内存空间，但是可以计算出原始图片的长宽，调用 options.**outWidth**/**outHeight**获取出图片的宽高，然后通过一定的算法，即可得到适合的 inSampleSize，这里感谢**街神**提供的代码——摘自鸿洋blog！

```
public static int caculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    int width = options.outWidth;
    int height = options.outHeight;
    int inSampleSize = 1;
    if (width > reqWidth || height > reqHeight) {
        int widthRadio = Math.round(width * 1.0f / reqWidth);
        int heightRadio = Math.round(height * 1.0f / reqHeight);
        inSampleSize = Math.max(widthRadio, heightRadio);
    }
    return inSampleSize;
}
```

然后使用下上述的方法即可：

```
BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true; // 设置了此属性一定要记得将值设置为false
Bitmap bitmap = null;
bitmap = BitmapFactory.decodeFile(url, options);
options.inSampleSize = computeSampleSize(options,128,128);
options.inPreferredConfig = Bitmap.Config.ARGB_4444;
/* 下面两个字段需要组合使用 */  
options.inPurgeable = true;
options.inInputShareable = true;
options.inJustDecodeBounds = false;
try {
    bitmap = BitmapFactory.decodeFile(url, options);
} catch (OutOfMemoryError e) {
        Log.e(TAG, "OutOfMemoryError");
}
```

------

## 3.及时回收图像

如果引用了大量的Bitmap对象，而应用又不需要同时显示所有图片。可以将暂时不用到的Bitmap对象 及时回收掉。对于一些明确知道图片使用情况的场景可以主动recycle回收，比如引导页的图片，使用 完就recycle，帧动画，加载一张，画一张，释放一张！使用时加载，不显示时直接置null或recycle！ 比如：imageView.setImageResource(0); 不过某些情况下会出现特定图片反复加载，释放，再加载等，低效率的事情...

------

## 4.其他方法

下面这些方法，我并没有用过，大家可以自行查阅相关资料：

### 1.简单通过SoftReference引用方式管理图片资源

建个SoftReference的hashmap 使用图片时先查询这个hashmap是否有softreference， softreference里的图片是否为空， 如果为空就加载图片到softreference并加入hashmap。 无需再代码里显式的处理图片的回收与释放，gc会自动处理资源的释放。 这种方式处理起来简单实用，能一定程度上避免前一种方法反复加载释放的低效率。但还不够优化。

**示例代码：**

```
private Map<String, SoftReference<Bitmap>> imageMap 
                                           = new HashMap<String, SoftReference<Bitmap>>();

public Bitmap loadBitmap(final String imageUrl,final ImageCallBack imageCallBack) {
    SoftReference<Bitmap> reference = imageMap.get(imageUrl);
    if(reference != null) {
        if(reference.get() != null) {
            return reference.get();
        }
    }
    final Handler handler = new Handler() {
        public void handleMessage(final android.os.Message msg) {
            //加入到缓存中
            Bitmap bitmap = (Bitmap)msg.obj;
            imageMap.put(imageUrl, new SoftReference<Bitmap>(bitmap));
            if(imageCallBack != null) {
                imageCallBack.getBitmap(bitmap);
            }
        }
    };
    new Thread(){
        public void run() {
            Message message = handler.obtainMessage();
            message.obj = downloadBitmap(imageUrl);
            handler.sendMessage(message);
        }
    }.start();
    return null ;
}

// 从网上下载图片
private Bitmap downloadBitmap (String imageUrl) {
    Bitmap bitmap = null;
    try {
        bitmap = BitmapFactory.decodeStream(new URL(imageUrl).openStream());
        return bitmap ;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    } 
}
public interface ImageCallBack{
    void getBitmap(Bitmap bitmap);
}
```

### 2.LruCache + sd的缓存方式

> Android 3.1版本起，官方还提供了LruCache来进行cache处理，当存储Image的大小大于LruCache 设定的值，那么近期使用次数最少的图片就会被回收掉，系统会自动释放内存！

**使用示例**：

步骤：

1）要先设置缓存图片的内存大小，我这里设置为手机内存的1/8, 手机内存的获取方式：int MAXMEMONRY = (int) (Runtime.getRuntime() .maxMemory() / 1024);

2）LruCache里面的键值对分别是URL和对应的图片

3）重写了一个叫做sizeOf的方法，返回的是图片数量。

```
private LruCache<String, Bitmap> mMemoryCache;
private LruCacheUtils() {
    if (mMemoryCache == null)
        mMemoryCache = new LruCache<String, Bitmap>(
                MAXMEMONRY / 8) {
            @Override
            protected int sizeOf(String key, Bitmap bitmap) {
                // 重写此方法来衡量每张图片的大小，默认返回图片数量。
                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;
            }

            @Override
            protected void entryRemoved(boolean evicted, String key,
                    Bitmap oldValue, Bitmap newValue) {
                Log.v("tag", "hard cache is full , push to soft cache");
               
            }
        };
}
```

4）下面的方法分别是清空缓存、添加图片到缓存、从缓存中取得图片、从缓存中移除。

移除和清除缓存是必须要做的事，因为图片缓存处理不当就会报内存溢出，所以一定要引起注意。

```
public void clearCache() {
    if (mMemoryCache != null) {
        if (mMemoryCache.size() > 0) {
            Log.d("CacheUtils",
                    "mMemoryCache.size() " + mMemoryCache.size());
            mMemoryCache.evictAll();
            Log.d("CacheUtils", "mMemoryCache.size()" + mMemoryCache.size());
        }
        mMemoryCache = null;
    }
}

public synchronized void addBitmapToMemoryCache(String key, Bitmap bitmap) {
    if (mMemoryCache.get(key) == null) {
        if (key != null && bitmap != null)
            mMemoryCache.put(key, bitmap);
    } else
        Log.w(TAG, "the res is aready exits");
}

public synchronized Bitmap getBitmapFromMemCache(String key) {
    Bitmap bm = mMemoryCache.get(key);
    if (key != null) {
        return bm;
    }
    return null;
}

/**
 * 移除缓存
 * 
 * @param key
 */
public synchronized void removeImageCache(String key) {
    if (key != null) {
        if (mMemoryCache != null) {
            Bitmap bm = mMemoryCache.remove(key);
            if (bm != null)
                bm.recycle();
        }
    }
}
```

上述内容摘自——[图片缓存之内存缓存技术LruCache,软引用](http://blog.chinaunix.net/uid-26930580-id-4138306.html)

------

## 本节小结：

> 本节给大家讲解了OOM问题的发生缘由，也总结了一下网上给出的一些避免因Bitmap而引起OOM 的一些方案，因为公司做的APP都是地图类的，很少涉及到图片，所以笔者并没有遇到过OOM的问题， 所以对此并不怎么熟悉~后续在进阶课程的内存管理，我们再慢慢纠结这个OOM的问题，好的， 本节就到这里，谢谢~

# 3.权限问题。

# 4.监听回调

## 3.1.1 基于监听的事件处理机制

### *分类* [Android 基础入门教程](https://www.runoob.com/w3cnote_genre/android)

## 本节引言：

> 第二章我们学习的是Android的UI控件，我们可以利用这些控件构成一个精美的界面，但是仅仅是界面而已；下一步就要开始学习逻辑与业务实现了，本章节讲解的是Android的事件处理机制！何为事件处理机制？举个 简单的例子，比如点击一个按钮，我们向服务器发送登陆请求！当然，Android中的事件处理机制不止这一种， 比如屏幕发生选择，我们点击了屏幕上某个区域...简单点说，事件处理机制就是我们和UI发生交互时，我们在背后添加一些小动作而已！本节我们来介绍使用的最频繁的一种：基于监听的事件处理机制！

------

## 1.基于监听的时间处理机制模型:

**流程模型图：**

![img](https://www.runoob.com/wp-content/uploads/2015/07/4109430.jpg)

**文字表述：**

> 事件监听机制中由**事件源**，**事件**，**事件监听器**三类对象组成 处理流程如下: **Step 1:**为某个事件源(组件)设置一个监听器,用于监听用户操作 **Step 2:**用户的操作,触发了事件源的监听器 **Step 3:**生成了对应的事件对象 **Step 4:**将这个事件源对象作为参数传给事件监听器 **step 5:**事件监听器对事件对象进行判断,执行对应的事件处理器(对应事件的处理方法)

**归纳：**

> 事件监听机制是一种委派式的事件处理机制,事件源(组件)事件处理委托给事件监听器 当事件源发生指定事件时,就通知指定事件监听器,执行相应的操作

------

## 2.五种不同的使用形式：

我们以下面这个： **简单的按钮点击,提示Toast信息的程序；**使用五种不同的形式来实现！

**效果图：**

![img](https://www.runoob.com/wp-content/uploads/2015/07/61197180.jpg)

------

### 1）直接用匿名内部类

> 平时最常用的一种:直接setXxxListener后,重写里面的方法即可; 通常是临时使用一次,复用性不高！

实现代码如下：**MainAcivity.java:**

```
package com.jay.example.innerlisten;    
    
import android.os.Bundle;    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.Button;    
import android.widget.Toast;    
import android.app.Activity;    
    
    
public class MainActivity extends Activity {    
    private Button btnshow;    
        
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
        btnshow = (Button) findViewById(R.id.btnshow);    
        btnshow.setOnClickListener(new OnClickListener() {    
            //重写点击事件的处理方法onClick()    
            @Override    
            public void onClick(View v) {    
                //显示Toast信息    
                Toast.makeText(getApplicationContext(), "你点击了按钮", Toast.LENGTH_SHORT).show();    
            }    
        });    
    }        
} 
```

------

### 2）使用内部类

> 和上面的匿名内部类不同哦！ 使用优点:可以在该类中进行复用,可直接访问外部类的所有界面组件！

实现代码如下：**MainAcivity.java:**

```
package com.jay.example.innerlisten;    
    
import android.os.Bundle;    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.Button;    
import android.widget.Toast;    
import android.app.Activity;    
    
    
public class MainActivity extends Activity {    
    private Button btnshow;    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
        btnshow = (Button) findViewById(R.id.btnshow);    
        //直接new一个内部类对象作为参数    
        btnshow.setOnClickListener(new BtnClickListener());    
    }     
    //定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法    
    class BtnClickListener implements View.OnClickListener    
    {    
        @Override    
        public void onClick(View v) {    
            Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();   
        }    
    }    
} 
```

------

### 3）使用外部类：

> 就是另外创建一个处理事件的Java文件,这种形式用的比较少！因为外部类不能直接访问用户界面 类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁！

ps:为了演示传参,这里用TextView代替Toast提示！

![img](https://www.runoob.com/wp-content/uploads/2015/07/72939526.jpg)

实现代码如下：**MyClick.java:**

```
package com.jay.example.innerlisten;    
    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.TextView;    
    
public class MyClick implements OnClickListener {    
    private TextView textshow;    
    //把文本框作为参数传入    
    public MyClick(TextView txt)    
    {    
        textshow = txt;    
    }    
    @Override    
    public void onClick(View v) {    
        //点击后设置文本框显示的文字    
        textshow.setText("点击了按钮!");    
    }    
}
```

**MainActivity.java**

```
package com.jay.example.innerlisten;    
import android.os.Bundle;    
import android.widget.Button;    
import android.widget.TextView;    
import android.app.Activity;    
    
    
public class MainActivity extends Activity {    
    private Button btnshow;    
    private TextView txtshow;    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
        btnshow = (Button) findViewById(R.id.btnshow);    
        txtshow = (TextView) findViewById(R.id.textshow);    
        //直接new一个外部类，并把TextView作为参数传入    
        btnshow.setOnClickListener(new MyClick(txtshow));    
    }         
} 
```

------

### 4）直接使用Activity作为事件监听器

> 只需要让Activity类实现XxxListener事件监听接口,在Activity中定义重写对应的事件处理器方法 eg:Actitity实现了OnClickListener接口,重写了onClick(view)方法在为某些组建添加该事件监听对象 时,直接setXxx.Listener(this)即可

实现代码如下：**MainAcivity.java:**

```
package com.jay.example.innerlisten;    
import android.os.Bundle;    
import android.view.View;    
import android.view.View.OnClickListener;    
import android.widget.Button;    
import android.widget.Toast;    
import android.app.Activity;    
    
//让Activity方法实现OnClickListener接口    
public class MainActivity extends Activity implements OnClickListener{    
    private Button btnshow;    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);    
            
        btnshow = (Button) findViewById(R.id.btnshow);    
        //直接写个this    
        btnshow.setOnClickListener(this);    
    }    
    //重写接口中的抽象方法    
    @Override    
    public void onClick(View v) {    
        Toast.makeText(getApplicationContext(), "点击了按钮", Toast.LENGTH_SHORT).show();         
    }         
}   
```

------

### 5）直接绑定到标签:

> 就是直接在xml布局文件中对应得Activity中定义一个事件处理方法 eg:public void myClick(View source) source对应事件源(组件) 接着布局文件中对应要触发事件的组建,设置一个属性:onclick = "myclick"即可

实现代码如下：**MainAcivity.java:**

```
package com.jay.example.caller;    
    
import android.app.Activity;    
import android.os.Bundle;    
import android.view.View;    
import android.widget.Toast;    
    
public class MainActivity extends Activity {    
    @Override    
    protected void onCreate(Bundle savedInstanceState) {    
        super.onCreate(savedInstanceState);    
        setContentView(R.layout.activity_main);     
    }    
    //自定义一个方法,传入一个view组件作为参数    
    public void myclick(View source)    
    {    
        Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();    
    }    
} 
```

**main.xml布局文件:**

```
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    
    xmlns:tools="http://schemas.android.com/tools"    
    android:id="@+id/LinearLayout1"    
    android:layout_width="match_parent"    
    android:layout_height="match_parent"    
    android:orientation="vertical" >    
    <Button     
        android:layout_width="wrap_content"    
        android:layout_height="wrap_content"    
        android:text="按钮"    
        android:onClick="myclick"/>    
 </LinearLayout> 
 
```

------

## 本节小结

> 本节给大家介绍了Android中的事件处理机制，例子中的是onClickListener点击事件，当然除了这个以外还有其他的事件，比如onItemClickListener，凡是需要通过setXxxListener这些，基本上都是基于事件监听的！ 另外这五种方式用的比较多的是：1，2，3，5几种，看具体情况而定~

# 5.handler

主线程像子线程发送数据

子线程返回数据给主线程

## 3.3 Handler消息传递机制浅析

### *分类* [Android 基础入门教程](https://www.runoob.com/w3cnote_genre/android)

## 本节引言

前两节中我们对Android中的两种事件处理机制进行了学习，关于响应的事件响应就这两种；本节给大家讲解的 是Activity中UI组件中的信息传递Handler，相信很多朋友都知道，Android为了线程安全，并不允许我们在UI线程外操作UI；很多时候我们做界面刷新都需要通过Handler来通知UI组件更新！除了用Handler完成界面更新外，还可以使用runOnUiThread()来更新，甚至更高级的事务总线，当然，这里我们只讲解Handler，什么是Handler，执行流程，相关方法，子线程与主线程中中使用Handler的区别等！

------

## 1.学习路线图：

![img](https://www.runoob.com/wp-content/uploads/2015/07/70402782.jpg)

------

## 2.Handler类的引入:

![img](https://www.runoob.com/wp-content/uploads/2015/07/90456225.jpg)

------

## 3.Handler的执行流程图：

![img](https://www.runoob.com/wp-content/uploads/2015/07/25345060.jpg)

**流程图解析:** **相关名词**

> - **UI线程**:就是我们的主线程,系统在创建UI线程的时候会初始化一个Looper对象,同时也会创建一个与其关联的MessageQueue;
> - **Handler**:作用就是发送与处理信息,如果希望Handler正常工作,在当前线程中要有一个Looper对象
> - **Message**:Handler接收与处理的消息对象
> - **MessageQueue**:消息队列,先进先出管理Message,在初始化Looper对象时会创建一个与之关联的MessageQueue;
> - **Looper**:每个线程只能够有一个Looper,管理MessageQueue,不断地从中取出Message分发给对应的Handler处理！

**简单点说：**

> 当我们的子线程想修改Activity中的UI组件时,我们可以新建一个Handler对象,通过这个对象向主线程发送信息;而我们发送的信息会先到主线程的MessageQueue进行等待,由Looper按先入先出顺序取出,再根据message对象的what属性分发给对应的Handler进行处理！

------

## 4.Handler的相关方法:

> - void **handleMessage**(Message msg):处理消息的方法,通常是用于被重写!
> - **sendEmptyMessage**(int what):发送空消息
> - **sendEmptyMessageDelayed**(int what,long delayMillis):指定延时多少毫秒后发送空信息
> - **sendMessage**(Message msg):立即发送信息
> - **sendMessageDelayed**(Message msg):指定延时多少毫秒后发送信息
> - final boolean **hasMessage**(int what):检查消息队列中是否包含what属性为指定值的消息 如果是参数为(int what,Object object):除了判断what属性,还需要判断Object属性是否为指定对象的消息

------

## 5.Handler的使用示例：

### 1）Handler写在主线程中

> 在主线程中,因为系统已经初始化了一个Looper对象,所以我们直接创建Handler对象,就可以进行信息的发送与处理了！

**代码示例：** 简单的一个定时切换图片的程序,通过Timer定时器,定时修改ImageView显示的内容,从而形成帧动画

**运行效果图：**

![img](https://www.runoob.com/wp-content/uploads/2015/07/40239012.jpg)

**实现代码：**

```
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    xmlns:tools="http://schemas.android.com/tools"  
    android:id="@+id/RelativeLayout1"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:gravity="center"  
    tools:context="com.jay.example.handlerdemo1.MainActivity" >  
  
    <ImageView  
        android:id="@+id/imgchange"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_alignParentLeft="true"  
        android:layout_alignParentTop="true" />  
  
</RelativeLayout> 
```

**MainActivity.java：**

```
public class MainActivity extends Activity {  
  
    //定义切换的图片的数组id  
    int imgids[] = new int[]{  
        R.drawable.s_1, R.drawable.s_2,R.drawable.s_3,  
        R.drawable.s_4,R.drawable.s_5,R.drawable.s_6,  
        R.drawable.s_7,R.drawable.s_8  
    };  
    int imgstart = 0;  
      
    final Handler myHandler = new Handler()  
    {  
      @Override  
      //重写handleMessage方法,根据msg中what的值判断是否执行后续操作  
      public void handleMessage(Message msg) {  
        if(msg.what == 0x123)  
           {  
            imgchange.setImageResource(imgids[imgstart++ % 8]);  
           }  
        }  
    };  
    
      
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        final ImageView imgchange = (ImageView) findViewById(R.id.imgchange);  
         
        //使用定时器,每隔200毫秒让handler发送一个空信息  
        new Timer().schedule(new TimerTask() {            
            @Override  
            public void run() {  
                myHandler.sendEmptyMessage(0x123);  
                  
            }  
        }, 0,200);  
    }  
  
} 
```

------

### 2）Handler写在子线程中

如果是Handler写在了子线程中的话,我们就需要自己创建一个Looper对象了!创建的流程如下:

> **1 )**直接调用Looper.prepare()方法即可为当前线程创建Looper对象,而它的构造器会创建配套的MessageQueue; **2 )**创建Handler对象,重写handleMessage( )方法就可以处理来自于其他线程的信息了! **3 )**调用Looper.loop()方法启动Looper

使用示例： 输入一个数，计算后通过Toast输出在这个范围内的所有质数

实现代码： **main.xml：**

```
<LinearLayout  
    xmlns:android="http://schemas.android.com/apk/res/android"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:orientation="vertical">  
    <EditText  
        android:id="@+id/etNum"  
        android:inputType="number"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:hint="请输入上限"/>  
    <Button  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:onClick="cal"  
        android:text="计算"/>    
</LinearLayout>  
```

**MainActivity.java:**

```
public class CalPrime extends Activity  
{  
    static final String UPPER_NUM = "upper";  
    EditText etNum;  
    CalThread calThread;  
    // 定义一个线程类  
    class CalThread extends Thread  
    {  
        public Handler mHandler;  
  
        public void run()  
        {  
            Looper.prepare();  
            mHandler = new Handler()  
            {  
                // 定义处理消息的方法  
                @Override  
                public void handleMessage(Message msg)  
                {  
                    if(msg.what == 0x123)  
                    {  
                        int upper = msg.getData().getInt(UPPER_NUM);  
                        List<Integer> nums = new ArrayList<Integer>();  
                        // 计算从2开始、到upper的所有质数  
                        outer:  
                        for (int i = 2 ; i <= upper ; i++)  
                        {  
                            // 用i处于从2开始、到i的平方根的所有数  
                            for (int j = 2 ; j <= Math.sqrt(i) ; j++)  
                            {  
                                // 如果可以整除，表明这个数不是质数  
                                if(i != 2 && i % j == 0)  
                                {  
                                    continue outer;  
                                }  
                            }  
                            nums.add(i);  
                        }  
                        // 使用Toast显示统计出来的所有质数  
                        Toast.makeText(CalPrime.this , nums.toString()  
                            , Toast.LENGTH_LONG).show();  
                    }  
                }  
            };  
            Looper.loop();  
        }  
    }  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        etNum = (EditText)findViewById(R.id.etNum);  
        calThread = new CalThread();  
        // 启动新线程  
        calThread.start();  
    }  
    // 为按钮的点击事件提供事件处理函数  
    public void cal(View source)  
    {  
        // 创建消息  
        Message msg = new Message();  
        msg.what = 0x123;  
        Bundle bundle = new Bundle();  
        bundle.putInt(UPPER_NUM ,  
            Integer.parseInt(etNum.getText().toString()));  
        msg.setData(bundle);  
        // 向新线程中的Handler发送消息  
        calThread.mHandler.sendMessage(msg);  
    }  
} 
```

PS:本例子来自于《Android疯狂讲义》~

------

## 本节小结

本节对Android中的Handler事件传递进行了简单的分析，要分清楚Handler，Message，MessageQueue， Loop的概念，以及Handler写在主线程中以及子线程中的区别

# 6.recycleview局部刷新，找到对应的item

# 7.spring事务，日志打印

时间计算的时候，最开始是在方法前重复添加计算时间的代码，后面发现可以向事务那样设置一个切面。我主要是为了查看我给每一个用户返回一个推荐列表的时候，用了多少的时间。

# 8.spring字符编码问题

# 问题描述

在使用springMVC框架构建web应用，返回http请求json格式的数据，中文乱码。

# 原因分析

我们通常使用@ResponseBody注解使 controller回应相应的数据而不是去渲染某个页面。如果请求的是非英文格式的字符串，往往在客户端显示的是乱码。

# 9.找不到配置文件的异常

```
org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML ``document from ``class` `path resource [com/herman/ss/controller]; nested exception is java.io.FileNotFoundException: ``class` `path resource [com/herman/ss/controller] cannot be opened because it does not exist
```

> 解释：这个的意思是说，没有找配置文件为controller的xml，修改一下配置文件名字即可。

```
<``init-param``> `` ``<``param-name``>contextConfigLocation</``param-name``> `` ``<``param-value``>classpath:com/herman/ss/config/testAjax.xml</``param-value``> ``</``init-param``>
```

# 10**bean的名字name或者id或者别名alias已经存在**

```
org.springframework.beans.factory.parsing.BeanDefinitionParsingException: ``Configuration problem: Bean name ``'a'` `is already used in ``this` `<beans> element
```

# 11、bean的自动加载找不到相对应的bean问题**

```
org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.yyc.ym.biz.YycBiz] found ``for` `dependency: expected at least ``1` `bean which qualifies as autowire candidate ``for` `this` `dependency. Dependency annotations: {``@org``.springframework.beans.factory.annotation.Autowired(required=``true``)}
```

> 解决方法：在配置文件中的<beans>根节点下加default-autowire="byName" default-lazy-init="true"或者<context:component-scan base-package="com.xxx.dao.*"></context:component-scan>包下面用*匹配
>
> 

# 数据库设计——评论回复和android怎么显示的问题

一般系统发展到一定时候，就会需要加上评论功能。评论也会有很多形式，不同形式的评论展示表的设计也不一样。这里介绍几种比较常见的评论。

1、一问一答

```
张三：文章写的不错。
作者 回复 张三：谢谢你的认可
```

这种评论是比较简单的，满足了基本的评论。

| 字段名                             | 类型          | 注释                        |
| ---------------------------------- | ------------- | --------------------------- |
| id                                 | bigint(64)    | 主键                        |
| target_type                        | varchar(20)   | 目标类型:具体对哪个业务评论 |
| **target_id（dynamic_id)**         | bigint(64)    | 目标id:具体哪个业务对应id   |
| content                            | varchar(1024) | 评论内容                    |
| **from_user_id（comment_user_id)** | bigint(64)    | 评论用户id                  |
| **to_user_id**                     | bigint(64)    | 评论目标用户id              |
| create_time                        | datetime      | 创建时间                    |
| del_flag                           | char(1)       | 删除标记 1:删除;0:未删除    |

如果是评论某个业务，那么to_user_id可以为空；
如果是对评论进行回复，那么to_user_id是目标用户id，from_user_id是评论用户id；
可以根据to_user_id是否为空来判断是评论业务还是回复评论；
target_type,target_id：主要是可以评论不同业务模块，你的这套评论可以适用各种业务。

2、评论回复评论
不光可以评论业务，还可以对评论进行评论

```
张三：文章很的可以
李四 回复 张三：你的名字很low
张三 回复 李四：你找事情
```

像这种评论为主的功能，你可以设计两个表，也可以设计一个表，
（1）、两个表的方案：
评论表：

| 字段名       | 类型          | 注释                        |
| ------------ | ------------- | --------------------------- |
| id           | bigint(64)    | 主键                        |
| target_type  | varchar(20)   | 目标类型:具体对哪个业务评论 |
| target_id    | bigint(64)    | 目标id:具体哪个业务对应id   |
| content      | varchar(1024) | 评论内容                    |
| from_user_id | bigint(64)    | 评论用户id                  |
| create_time  | datetime      | 创建时间                    |
| del_flag     | char(1)       | 删除标记 1:删除;0:未删除    |

说明：这里只记录对业务功能的评论。

评论回复表：

| 字段名       | 类型          | 注释                     |
| ------------ | ------------- | ------------------------ |
| id           | bigint(64)    | 主键                     |
| comment_id   | bigint(64)    | 评论表id                 |
| content      | varchar(1024) | 评论内容                 |
| from_user_id | bigint(64)    | 评论用户id               |
| to_user_id   | bigint(64)    | 评论目标用户id           |
| create_time  | datetime      | 创建时间                 |
| del_flag     | char(1)       | 删除标记 1:删除;0:未删除 |

说明：如果需要<u>对评论的评论在进行回复，那么可以加一个parent_id，</u>表示评论回复表id。

（2）、一个表

| 字段名       | 类型          | 注释                                       |
| ------------ | ------------- | ------------------------------------------ |
| id           | bigint(64)    | 主键                                       |
| parent_id    | bigint(64)    | 父类id，大于0时为评论的回复                |
| target_type  | varchar(20)   | 目标类型:具体对哪个业务评论                |
| target_id    | bigint(64)    | 目标id:具体哪个业务对应id                  |
| content      | varchar(1024) | 评论内容                                   |
| from_user_id | bigint(64)    | 评论用户id                                 |
| to_user_id   | bigint(64)    | 评论目标用户id,parent_id为0的时候该值也为0 |
| create_time  | datetime      | 创建时间                                   |
| del_flag     | char(1)       | 删除标记 1:删除;0:未删除                   |

说明：一张表搞定评论、评论的回复；
当评论业务的时候，to_user_id为0；
当回复评论的时候，to_user_id为目标用户id；

到这里几种常见的评论表设计完成了。每个系统的功能不一样，你可以根据自己的需求进行调整。

# 数据库删除信息的问题

最开始想的直接删除，最后是通过修改数据库表增加字段，判断当前状态

# ————————————

# 3.腾讯广告算法大赛

# 第一份

本届算法大赛的题目为“**广告受众基础属性预估**”，赛题提供了90天用户点击广告行为日志及广告的基本属性，让大家预测用户性别和年龄。为了帮助大家快速理解本次赛事的题目，我和大家简单分享一下我对于本次赛题数据的理解和一些解题思路。

## 01**赛题数据**

赛题数据其实还是比较干净清爽的，用户基本属性信息只需要我们预测性别和年龄，其余的都是用户点击日志和广告相关信息。初期需要去理解**每个变量的含义**，比如creative_id广告素材可能由文案、图片和视频组成，一个广告包含多个广告素材，因此**广告素材生成的流程**也需要加以了解。“比较”是影响广告投放的重要环节之一，首先结合用户画像和卖点提炼，然后确定使用场景，最后进行素材的筛选和加工。

对数据和业务的基本认识可以帮助我们深入理解赛题，挖掘更多有用信息。

## 02**解题思路**

用户的历史点击行为可以反映其**属性特点**，比如**男性偏爱电子产品、游戏**等，**女性则更偏爱服饰、化妆品**等，所以从点击序列中挖掘信息更为重要。那么如何挖掘序列信息呢，这里的方法就比较多了，下面逐个介绍。

### 01**one-hot**

直接展开，保留所有信息，300多万维，可以直接放弃了。

### 02**Tfidf**

NLP中常用的做法，将用户点击序列中的creative_id或者ad_id集合看作一篇文档，将每个creative_id或者ad_id视为文档中的文字，然后使用tfidf。当然这也下来维度也非常高，可以通过参数调整来降低维度，比如sklearn中的TfidfVectorizer，可以使用max_df和min_df进行调整。

### 03**Word2vec**

把每个点击的creative_id或者ad_id当作一个词，把一个人90天内点击的creative_id或者ad_id列表当作一个句子，使用word2vec来构造creative_id或者ad_id嵌入表示。最后进行简单的统计操作得到用户的向量表示。这种序列简单聚合导致信息损失，显得是非常的粗糙，需要进一步引入attention等方法。

​		上述方法可以直接使用传统的**GBDT相关模型**进行，1.3应该没问题。下面可以考虑序列建模方式。例如**RNN/LSTM/GRU**，这类方法将用户行为看做一个序列，套用NLP领域常用的RNN/LSTM/GRU方法来进行建模。

# 第二份

本届赛题提供了用户在90天内的点击行为，从而预测出用户的年龄与性别。对于此次比赛，我将简单地从NLP的角度解析赛题，从而为大家提供**解题思路**。

## 01如何转化成NLP问题

首先，我们来看下如何和NLP问题联系起来。用户在90天内点击了不同的广告，我们可以**将每个广告看作一个单词word**，然后把这些单词连接起来组成一句话：**[creative_id_1,creative_id_2,…,creative_id_n]**。

由于每个广告有不同属性，如广告主id，并且每个用户点击广告也有不同属性，如点击次数，这样对于每个用户我们就可以得到8种文本。那么剩下的问题就是如何根据这8种文本预测用户的年龄和性别。在NLP中，预测文本的类别有许多模型，比如lstm, gru, transformer等。对于这8种文本，我们将它们看成正常的文本，然后输入到常见的NLP模型中，**在输出端做多分类即可**。

## 02如何解决OOV问题

OOV的全称是Out of Vocabulary, 在这里是指：测试集的某些广告不在训练集中，导致在训练的过程中，测试集中某些广告的embedding并没有被训练。因此，如果能够很好的解决OOV问题，那么就可以有效的提高成绩，这里主要有两种方法。第一种方法，我们可以**截断低频广告**，设置成unknown，那么对于测试集新出现的广告也可以直接设置成unknown。第二种方法是**通过w2v的方式**，预训练全部广告的embedding，然后在做训练时，把embedding的参数固定住。

### 03如何解决词表过大而造成的显存溢出问题

但现在有一个问题：广告有300w左右，如果将embedding的维度设置为128，那么显存会溢出。针对这个问题，接下来我会提供一些解决方案。在上文中说过，如果经过w2v的预训练，我们可以**把embedding的参数固定住**，因此我们没有必要把embedding矩阵放到显存中，我们可以把该矩阵放到cpu上，这样就不会占用显存了。另一种方法大家也有使用，就是**用类似keras的generator或者pytorch的dataloader**，然后利用gensim模型去寻找广告所对应的embedding。由于generator和dataloader都是多线程处理，所以寻找起来也非常快。

目前，我使用了8种基本广告特征和用户点击特征，然后花了两周时间对模型进行修改和调参，**达到了1.453的成绩**，由此可以看出这**8种文本信息**还是非常重要的。接下来，如果需要取得好的成绩，可能需要进行一些特征工程。

# 第三份

**
CountVectorizer, TfidfVectorizer** 

可以考虑词频统计特征，保留用户历史序列中的所有点击ID信息，当然tfidf也可以一起使用，这样下来会有90多w维；也可以考虑在参数上进行设置，如max_feature和min_df，以减少维度。可以考虑对所有ID类特征都进行这样的操作。

梳理下我们还有哪些特征可以加的，我想到的其实并不多，对于有效的特征会进行一系列的扩展，比如提取用户行为序列中creative_id的向量表示，可以使用不同的embedding方式，基本的glove、word2vec、deepwalk或者fasttext都是可以尝试的。对于tfidf后的结果进行主题分类，基本的SVD、LDA、NMF也都有尝试。

02后处理方法

后处理方法还是有千分位的提升，方法比较简单，在很多分类问题中都会产生奇效。下面给出优化过程，对应本赛题，**输入的概率矩阵是n\*10**。 

![img](https://mmbiz.qpic.cn/mmbiz_png/tq4iaariaCpMlpp48lkInY0dGT4mrG7CaHLys5Ioia8G9TRr9ZnJGTMLXbibfA2tICAm4FhvVGeUxiaOUa7Q1BFiaoYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

03模型选择

**Lightgbm****：**使用起来非常方便，不过很难往高分突破，用来进行融合还是蛮不错的。另外，在实践中使用gender的概率结果进行融合不能产生正向的效果，建议仅使用age的概率结果与nn进行融合。

**BiLSTM****：**我们首先选取三个比较强的ID特征，例如creative_id，ad_id和advertiser_id（这是我所选择的三输入，当然还能进行更多尝试，或者进行ID交叉组合构建新的序列），然后进行word2vec预训练得到embedding向量，对应三个bilstm层。对于其它构造出来的特征对应Dense层，最后进行concat。结构非常简单，收益也是非常高的。

经过bilstm后进行mean pooling或者max pooling，可以进一步考虑bilstm后接attention层。然后与其它特征concat后，再经过几层的mlp后作为接sigmoid或者softmax得到最终结果。

像attention、gru、lstm等操作基本上已经成为这道赛题的标配，暴力尝试组合就常常会有效果，如同堆积木一样，使用这些通用方式能堆出你想要的结构。

**DIN****：**序列建模，我们可以将本赛题任务转化为CTR问题，模型能够利用用户行为序列有效地刻画用户的行为兴趣，在用户行为丰富的情况下，有效利用用户历史行为数据精准地预估CTR（age/gender）。DIN引入attention模块，对用户行为序列中的embedding向量进行weighted-sum pooling。

# 4.用户画像总结

![img](https://csdnimg.cn/release/blogv2/dist/pc/img/original.png)

[很好还好还好](https://me.csdn.net/zzhhoubin) 2018-03-28 14:45:51 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png) 111284 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png) 收藏 206

文章标签： [用户画像](https://www.csdn.net/gather_25/MtTaEg0sMTQ0MDEtYmxvZwO0O0OO0O0O.html)

版权

​    最近在工作之余，结合自己的理解和论坛上的一些帖子，整理了份用户画像的文章，个人觉得这篇文章在宏观上很好地描述了用户画像的主要内容。（文章内的图片来源于不同帖子，权当分享，侵删）



## 一什么是用户画像

​    用户画像是指根据用户的属性、用户偏好、生活习惯、用户行为等信息而抽象出来的标签化用户模型。通俗说就是给用户打标签，而标签是通过对用户信息分析而来的高度精炼的特征标识。通过打标签可以利用一些高度概括、容易理解的特征来描述用户，可以让人更容易理解用户，并且可以方便计算机处理。

![img](https://img-blog.csdn.net/20180328143041683?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

用户画像是对现实世界中用户的建模，用户画像应该包含目标，方式，组织，标准，验证这5个方面。

**目标：**指的是描述人，认识人，了解人，理解人。

**方式：**又分为非形式化手段，如使用文字、语言、图像、视频等方式描述人；形式化手段，即使用数据的方式来刻画人物的画像。

**组织：**指的是结构化、非结构化的组织形式。

**标准：**指的是使用常识、共识、知识体系的渐进过程来刻画人物，认识了解用户。

**验证：**依据侧重说明了用户画像应该来源事实、经得起推理和检验。

![img](https://img-blog.csdn.net/2018032814305464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    在产品早期和发展期，会较多地借助用户画像，帮助产品人员理解用户的需求，想象用户使用的场景，产品设计从为所有人做产品变成为三四个人做产品，间接的降低复杂度。

## 二、用户画像的作用

在互联网、电商领域用户画像常用来作为精准营销、推荐系统的基础性工作，其作用总体包括：

（1）精准营销：根据历史用户特征，分析产品的潜在用户和用户的潜在需求，针对特定群体，利用短信、邮件等方式进行营销。

（2）用户统计：根据用户的属性、行为特征对用户进行分类后，统计不同特征下的用户数量、分布；分析不同用户画像群体的分布特征。

（3）数据挖掘：以用户画像为基础构建推荐系统、搜索引擎、广告投放系统，提升服务精准度。

（4）服务产品：对产品进行用户画像，对产品进行受众分析，更透彻地理解用户使用产品的心理动机和行为习惯，完善产品运营，提升服务质量。

（5）行业报告&用户研究：通过用户画像分析可以了解行业动态，比如人群消费习惯、消费偏好分析、不同地域品类消费差异分析

​    根据用户画像的作用可以看出，用户画像的使用场景较多，用户画像可以用来挖掘用户兴趣、偏好、人口统计学特征，主要目的是提升营销精准度、推荐匹配度，终极目的是提升产品服务，起到提升企业利润。用户画像适合于各个产品周期：从新用户的引流到潜在用户的挖掘、从老用户的培养到流失用户的回流等。

![img](https://img-blog.csdn.net/20180328143112574?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    总结来说，用户画像必须从实际业务场景出发，解决实际的业务问题，之所以进行用户画像，要么是获取新用户，要么是提升用户体验、或者挽回流失用户等具有明确的业务目标。

![img](https://img-blog.csdn.net/20180328143305527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![img](https://img-blog.csdn.net/20180328143314835?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![img](https://img-blog.csdn.net/20180328143321995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    另外关于用户画像数据维度的问题，并不是说数据维度越丰富越好，总之，画像维度的设计同样需要紧跟业务实际情况进行开展。

##  三、用户画像的分类

​    从画像方法来说，可以分为定性画像、定性+定量画像、定量画像

![img](https://img-blog.csdn.net/20180328143338629?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    从应用角度来看，可以分为行为画像、健康画像、企业信用画像、个人信用画像、静态产品画像、旋转设备画像、社会画像和经济画像等。

## 四、用户画像需要用到哪些数据

​    一般来说，根据具体的业务内容，会有不同的数据，不同的业务目标，也会使用不同的数据。在互联网领域，用户画像数据可以包括以下内容：

（1）人口属性：包括性别、年龄等人的基本信息

（2）兴趣特征：浏览内容、收藏内容、阅读咨询、购买物品偏好等

（3）消费特征：与消费相关的特征

（4）位置特征：用户所处城市、所处居住区域、用户移动轨迹等

（5）设备属性：使用的终端特征等

（6）行为数据：访问时间、浏览路径等用户在网站的行为日志数据

（7）社交数据：用户社交相关数据

![img](https://img-blog.csdn.net/20180328143347416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    用户画像数据来源广泛，这些数据是全方位了解用户的基础，这里以Qunar的画像为例，其画像数据主要维度如下所示，包括用户RFM信息、航线信息等。

![img](https://img-blog.csdn.net/20180328143404593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    Qunar的画像数据仓库构建都是基于Qunar基础数据仓库构建，然后按照维度进行划分。

![img](https://img-blog.csdn.net/20180328143412103?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 五、用户画像主要应用场景

a)用户属性

b)用户标签画像

c)用户偏好画像

d)用户流失

e)用户行为

f)产品设计

g) 个性化推荐、广告系统、活动营销、内容推荐、兴趣偏好

![img](https://img-blog.csdn.net/20180328143434331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 六、用户画像使用的技术方法

## 七、用户画像标签体系的建立

1、什么是标签体系

​    用户画像是对现实用户做的一个数学模型，在整个数学模型中，核心是怎么描述业务知识体系，而这个业务知识体系就是本体论，本体论很复杂，我们找到一个特别朴素的实现，就是标签。

​    标签是某一种用户特征的符号表示。是一种内容组织方式，是一种关联性很强的关键字，能方便的帮助我们找到合适的内容及内容分类。（注：简单说，就是你把用户分到多少个类别里面去，这些类是什么，彼此之间有什么关系，就构成了标签体系）

​    标签解决的是描述（或命名）问题，但在实际应用中，还需要解决数据之间的关联，所以通常将标签作为一个体系来设计，以解决数据之间的关联问题。

​    一般来说，将能关联到具体用户数据的标签，称为叶子标签。对叶子标签进行分类汇总的标签，称为父标签。父标签和叶子标签共同构成标签体系，但两者是相对概念。例如：下表中，地市、型号在标签体系中相对于省份、品牌，是叶子标签。

| 一级标签     | 二级标签   | 三级标签 | 四级标签 |
| ------------ | ---------- | -------- | -------- |
| 移动属性     | 用户所在地 | 省份     | 地市     |
| 手机品牌     | 品牌       | 型号     |          |
| 业务属性     | 用户等级   | 普通     |          |
| 音乐普通会员 |            |          |          |
| 音乐高级会员 |            |          |          |
| 音乐VIP会员  |            |          |          |

​    用户画像标签体系创建后一般要包含以下几个方面的内容

![img](https://img-blog.csdn.net/20180328143452662?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（1）标签分类

​    用户画像标签可以分为基础属性标签和行为属性标签。

![img](https://img-blog.csdn.net/2018032814350527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    由于基于一个目标的画像，其标签是在动态扩展的，所以其标签体系也没有统一的模板，在大分类上，与自身的业务特征有很大的关联，在整体思路上可以从横纵两个维度展开思考：横向是产品内数据和产品外数据，纵向是线上数据和线下数据。而正中间则是永恒不变的“人物基础属性”。

​    如果说其他的分类因企业特征而定，那么只有人物特征属性（至于名字叫什么不重要，关键是内涵）是各家企业不能缺失的板块。

​    所谓人物基础属性指的是：用户客观的属性而非用户自我表达的属性，也就是描述用户真实人口属性的标签。所谓非“自我表达”，举例来说，某产品内个人信息有性别一项，用户填写为“女”，而通过用户上传的身份证号，以及用户照片，用户购买的产品，甚至用户打来的客服电话，都发现该用户性别是“男性”。那么在人物基础属性中的性别，应该标识的是“男性”，但是用户信息标签部分，自我描述的性别则可能标注为女性。

（2）标签级别（标签的体系结构）

​    分级有两个层面的含义，其一是：指标到最低层级的涵盖的层级；其二是指：指标的运算层级。其一非常好理解，这里重点说运算层级。

​    标签从运算层级角度可以分为三层：事实标签、模型标签、预测标签。

​    事实标签：是通过对于原始数据库的数据进行统计分析而来的，比如用户投诉次数，是基于用户一段时间内实际投诉的行为做的统计。

​    模型标签：模型标签是以事实标签为基础，通过构建事实标签与业务问题之间的模型，进行模型分析得到。比如，结合用户实际投诉次数、用户购买品类、用户支付的金额等，进行用户投诉倾向类型的识别，方便客服进行分类处理。

​    预测标签：则是在模型的基础上做预测，比如针对投诉倾向类型结构的变化，预测平台舆情风险指数。

![img](https://img-blog.csdn.net/20180328143514111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（3）标签命名&赋值

​    我们用一张图来说明一下命名和赋值的差别，只要在构建用户标签的过程种，有意识的区别标签命名和赋值足矣，不再赘述。

![img](https://img-blog.csdn.net/20180328143523461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（4）标签属性

​    标签属性可以理解为针对标签进行的再标注，这一环节的工作主要目的是帮助内部理解标签赋值的来源，进而理解指标的含义。如图所示，可以总结为5种来源：

1、固有属性：是指这些指标的赋值体现的是用户生而有之或者事实存在的，不以外界条件或者自身认知的改变而改变的属性。比如：性别、年龄、是否生育等。

2、推导属性：由其他属性推导而来的属性，比如星座，我们可以通过用户的生日推导，比如用户的品类偏好，则可以通过日常购买来推导。

3、行为属性：产品内外实际发生的行为被记录后形成的赋值，比如用户的登陆时间，页面停留时长等。

4、态度属性：用户自我表达的态度和意愿。比如说我们通过一份问卷向用户询问一些问题，并形成标签，如询问用户：是否愿意结婚，是否喜欢某个品牌等。当然在大数据的需求背景下，利用问卷收集用户标签的方法效率显得过低，更多的是利用产品中相关的模块做了用户态度信息收集。

5、测试属性：测试属性是指来自用户的态度表达，但并不是用户直接表达的内容，而是通过分析用户的表达，结构化处理后，得出的测试结论。比如，用户填答了一系列的态度问卷，推导出用户的价值观类型等。

![img](https://img-blog.csdn.net/20180328143531458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    值得注意的是，一种标签的属性可以是多重的，比如：个人星座这个标签，既是固有属性，也是推导属性，它首先不以个人的意志为转移，同时可以通过身份证号推导而来。

​    即便你成功了建立用户画像的标签体系，也不意味着你就开启了用户画像的成功之路，因为有很大的可能是这些标签根本无法获得，或者说无法赋值。

​    标签无法赋值的原因有：数据无法采集（没有有效的渠道和方法采集到准确的数据，比如用户身份证号）、数据库不能打通、建模失败（预测指标无法获得赋值）等等。

 2、标签体系结构

​    标签体系可以归纳出如下的层级结构。

![img](https://img-blog.csdn.net/20180328143545675?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（1）原始输入层

​    主要指用户的历史数据信息，如会员信息、消费信息、网络行为信息。经过数据的清洗，从而达到用户标签体系的事实层。

（2）事实层

​    事实层是用户信息的准确描述层，其最重要的特点是，可以从用户身上得到确定与肯定的验证。如用户的人口属性、性别、年龄、籍贯、会员信息等。

（3）模型预测层

​    通过利用统计建模，数据挖掘、机器学习的思想，对事实层的数据进行分析利用，从而得到描述用户更为深刻的信息。如通过建模分析，可以对用户的性别偏好进行预测，从而能对没有收集到性别数据的新用户进行预测。还可以通过建模与数据挖掘，使用聚类、关联思想，发现人群的聚集特征。

（4）营销模型预测

​    利用模型预测层结果，对不同用户群体，相同需求的客户，通过打标签，建立营销模型，从而分析用户的活跃度、忠诚度、流失度、影响力等可以用来进行营销的数据。

（5）业务层

​    业务层可以是展现层。它是业务逻辑的直接体现，如图中所表示的，有车一族、有房一族等。

3、标签体系结构分类

​    一般来说，设计一个标签体系有3种思路，分别是：（1）结构化标签体系；（2）半结构化标签体系；（3）非结构化标签体系。

（1）结构化标签体系

​    简单地说，就是标签组织成比较规整的树或森林，有明确的层级划分和父子关系。结构化标签体系看起来整洁，又比较好解释，在面向品牌广告井喷时比较好用。性别、年龄这类人口属性标签，是最典型的结构化体系。下图就是Yahoo!受众定向广告平台采用的结构化标签体系。

![img](https://img-blog.csdn.net/20180328143555576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（2）半结构化标签体系

​    在用于效果广告时，标签设计的灵活性大大提高了。标签体系是不是规整，就不那么重要了，只要有效果就行。在这种思路下，用户标签往往是在行业上呈现出一定的并列体系，而各行业内的标签设计则以“逮住老鼠就是好猫”为最高指导原则，切不可拘泥于形式。下图是Bluekai聚合多家数据形成的半结构化标签体系。

![img](https://img-blog.csdn.net/20180328143603142?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（3）非结构化标签体系

​    非结构化，就是各个标签就事论事，各自反应各自的用户兴趣，彼此之间并无层级关系，也很难组织成规整的树状结构。非结构化标签的典型例子，是搜索广告里用的关键词。还有Facebook用的用户兴趣词。

 ***\*4、\**\**用户画像标签层级的建模方法\****

​    用户画像的核心是标签的建立，用户画像标签建立的各个阶段使用的模型和算法如下图所示。

![img](https://img-blog.csdn.net/20180328143609840?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20180328143621222?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

原始数据层。对原始数据，我们主要使用文本挖掘的算法进行分析如常见的TF-IDF、TopicModel主题模型、LDA 等算法，主要是对原始数据的预处理和清洗，对用户数据的匹配和标识。

事实标签层。通过文本挖掘的方法，我们从数据中尽可能多的提取事实数据信息，如人口属性信息，用户行为信息，消费信息等。其主要使用的算法是分类和聚类。分类主要用于预测新用户，信息不全的用户的信息，对用户进行预测分类。聚类主要用于分析挖掘出具有相同特征的群体信息，进行受众细分，市场细分。对于文本的特征数据，其主要使用相似度计算，如余弦夹角，欧式距离等。

模型标签层。使用机器学习的方法，结合推荐算法。模型标签层完成对用户的标签建模与用户标识。其主要可以采用的算法有回归，决策树，支持向量机等。通过建模分析，我们可以进一步挖掘出用户的群体特征和个性权重特征，从而完善用户的价值衡量，服务满意度衡量等。

预测层。也是标签体系中的营销模型预测层。这一层级利用预测算法，如机器学习中的监督学习，计量经济学中的回归预测，数学中的线性规划等方法。实习对用户的流失预测，忠实度预测，兴趣程度预测等等，从而实现精准营销，个性化和定制化服务。

不同的标签层级会考虑使用对其适用的建模方法，对一些具体的问题，有专门的文章对其进行研究。

***\*八、\** \**用户画像基本步骤\**[F2]** 

​    根据具体业务规则确定用户画像方向后，开展用户画像分析，总体来说，一个用户画像流程包括以下三步。（1）用户画像的基本方向；（2）用户数据收集；（3）用户标签建模。

![img](https://img-blog.csdn.net/20180328143629828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    另外，需要注意的是用户画像的时效性，构建画像的数据多为历史数据，但用户的行为、偏好等特征多会随着时间的推移而发生变化。

***\*九、\** \**用户画像验证\****

![img](https://img-blog.csdn.net/20180328143640489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

***\*十、\** \**用户画像的实际例子\****

​    注：此处涉及到工作中的项目内容，由于保密，就不能分享了

***\*十一、\**  \**用户画像平台\**\**&\**\**架构\****

用户画像平台需要实现的功能。

![img](https://img-blog.csdn.net/20180328143751570?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    用户画像系统技术架构

![img](https://img-blog.csdn.net/20180328143759155?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（1）  数据处理

a、数据指标的梳理来源于各个系统日常积累的日志记录系统，通过sqoop导入hdfs,也可以用代码来实现，比如spark的jdbc连接传统数据库进行数据的cache。还有一种方式，可以通过将数据写入本地文件，然后通过sparksql的load或者hive的export等方式导入HDFS。

b、通过hive编写UDF 或者hiveql根据业务逻辑拼接ETL，使用户对应上不同的用户标签数据（这里的指标可以理解为每个用户打上了相应的标签），生成相应的源表数据,以便于后续用户画像系统，通过不同的规则进行标签宽表的生成。

（2）  数据平台

a、数据平台应用的分布式文件系统为Hadoop的HDFS，因为Hadoop2.0以后,任何的大数据应用都可以通过ResoureManager申请资源，注册服务。比如(sparksubmit、hive）等等。而基于内存的计算框架的出现，就并不选用Hadoop的MapReduce了。当然很多离线处理的业务，很多人还是倾向于使用Hadoop,但是Hadoop封装的函数只有map和Reduce太过单一，而不像spark一类的计算框架有更多封装的函数（可参考博客spark专栏）。可以大大提升开发效率。

b、计算的框架选用Spark以及RHadoop,这里Spark的主要用途有两种，一种是对于数据处理与上层应用所指定的规则的数据筛选过滤，(通过Scala编写spark代码提交至sparksubmit)。一种是服务于上层应用的SparkSQL（通过启动spark thriftserver与前台应用进行连接）。 RHadoop的应用主要在于对于标签数据的打分，比如利用协同过滤算法等各种推荐算法对数据进行各方面评分。

c、MongoDB内存数据的应用主要在于对于单个用户的实时的查询，也是通过对spark数据梳理后的标签宽表进行数据格式转换(json格式）导入mongodb,前台应用可通过连接mongodb进行数据转换，从而进行单个标签的展现。（当然也可将数据转换为Redis中的key value形式，导入Redis集群)

d、mysql的作用在于针对上层应用标签规则的存储，以及页面信息的展现。后台的数据宽表是与spark相关联，通过连接mysql随后cache元数据进行filter、select、map、reduce等对元数据信息的整理,再与真实存在于Hdfs的数据进行处理。

（3）  面向应用

从刚才的数据整理、数据平台的计算，都已经将服务于上层应用的标签大宽表生成。（用户所对应的各类标签信息）。那么前台根据业务逻辑，勾选不同的标签进行求和、剔除等操作，比如本月流量大于200M用户（标签）+本月消费超过100元用户（标签）进行和的操作，通过前台代码实现sql的拼接，进行客户数目的探索。这里就是通过jdbc的方式连接spark的thriftserver，通过集群进行HDFS上的大宽表的运算求count。（这里要注意一点，很多sql聚合函数以及多表关联join 相当于hadoop的mapreduce的shuffle,很容易造成内存溢出，相关参数调整可参考本博客spark栏目中的配置信息）这样便可以定位相应的客户数量，从而进行客户群、标签的分析，产品的策略匹配从而精准营销。

***\*十二、\**\**用户画像困难点、用户画像瓶颈\****

用户画像困难点主要表现为以下4个方面

![img](https://img-blog.csdn.net/20180328143820500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6aGhvdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

资料搜集和数据挖掘

​    在画像之前需要知道产品的用户特征和用户使用产品的行为等因素，从而从总体上掌握对用户需求需求

​     创建用户画像不是抽离出典型进行单独标签化的过程，而是要融合边缘环境的相关信息来进行讨论

定量调研分析

用户标签画像

我们的用户标签包含基本特征、社会身份、顾客用户生命周期、类目偏好等等。比如说你怎么判断一个人是不是对女装感兴趣，假设我们有一个类目就是女装，那很好办，如果你购买都是女装，那会认为你这个人对女装比较感兴趣。

挑战

我们期间遇到了两方面的挑战：

亿级画像系统实践和应用

记录和存储亿级用户的画像，支持和扩展不断增加的维度和偏好，毫秒级的更新，支撑个公司性化推荐、广告投放和精细化营销等产品。





